=================================================
**Лабораторная работа №4 Потоки ядра и их синхронизация**
=================================================

**Тема**: *Таймеры и workqueue*

**Цель**: *Научиться синхронизировать потоки в Linux*

Структура директории
-------------------------------------------
+-------------------+----------------------------------+ 
| Папка и файлы     |            Описание              |
+===================+==================================+ 
|        src        | Исходный код лабораторной работы |
+-------------------+----------------------------------+
|       Makefile    |     Файл для компиляции проекта  | 
+-------------------+----------------------------------+ 
|       README.rst  | Отчет о лабораторной работе      |
+-------------------+----------------------------------+

**Оглавление:**
----------------

      #. `Задание`_
      #. `Теория`_ 
      #. `Ход работы`_  
              #. `В проекте используються библиотеки`_
              #. `Так же нам понадобяться переменные`_
              #. `Рассмотрим функции`_ 
                        #. `Функция таймера`_
                        #. `Функция отложенного действия`_
                        #. `Печать структуры`_
                        #. `Удаление структуры`_
                        #. `Функция для первого потока`_
                        #. `Функция для второго потока`_
                        #. `Инициализации`_
                        #. `Выход`_
      #. `Сборка и тестирование модуля`_
      #. `Вывод`_


**Задание**
~~~~

* Изучить особенности работы таймеров и workqueue
* Реализовать два потока, запустить таймер и ворк в shared workqueue
* При срабатывании таймера проверить текущее значение jiffies, если оно кратно 11
* Остановить поток 1, иначе – таймер должен перезапустить себя через 17 jiffies
* Внутри ворка проверить текущее значение jiffies, если оно кратно 11 – остановить поток 2, иначе – ворк должен уснуть на 17 jiffies и перезапустить себя
* Добавить два связных списка, в которые аллоцировать и добавлять элементы со значениями jiffies, которые не привели к завершению потоков 1 и 2. Получается связь таймер - список 1 - поток 1. И ворк - список 2 - поток 2
* При выходе из потоков распечатывать списки
* Внутри ворка и таймера использовать правильные аллокации для новых элементов списка, правильную синхронизацию работы со списком
* Предусмотреть, что пользователь может выгрузить модуль до отработки всех таймеров и ворков

**Теория**
--------------

Очереди отложенных действий (workqueue) — это еще один, но совершенно другой, способ реализации отложенных операций. Очереди отложенных 
действий позволяют откладывать некоторые операции для последующего выполнения потоком пространства ядра (эти потоки ядра называют 
рабочими потоками - worker threads ) — отложенные действия всегда выполняются в контексте процесса. Поэтому код, выполнение которого 
отложено с помощью постановки в очередь отложенных действий, получает все преимущества, которыми обладает код, выполняющийся в контексте 
процесса, главное из которых — это возможность переходить в блокированные состояния.

Функция таймера в ядре выполняется в контексте прерывания (Не в контексте процесса! А конкретнее: в контексте обработчика прерывания 
системного таймера.), что накладывает на неё дополнительные ограничения:

*	Не разрешён доступ к пользовательскому пространству. Из-за отсутствия контекста процесса, нет пути к пользовательскому пространству, связанному с любым определённым процессом.
*	Указатель current не имеет смысла и не может быть использован, так как соответствующий код не имеет связи с процессом, который был прерван.
*	Не может быть выполнен переход в блокированное состояние и переключение контекста. Код в контексте прерывания не может вызвать schedule() или какую-то из форм wait_event(), и не может вызвать любые другие функции, которые могли бы перевести его в пассивное состояние, семафоры и подобные примитивы синхронизации также не должны быть использованы, поскольку они могут переключать выполнение в пассивное состояние.

**Ход работы**
-----------

**В проекте используються библиотеки**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* ``<linux/module.h>`` требуется для всех модулей
* ``<linux/kernel.h>`` требуется для системной информации
* ``<linux/init.h>`` используется для инициализации и закрытия модуля
* ``<linux/list.h>`` для создания списков
* ``<linux/slab.h>`` для более эффективного управления памятью
* ``<linux/kthread.h>`` для взаимодействия с потоками данных
* ``<linux/timer.h>`` для работы с таймерами
* ``<linux/workqueue.h>`` для работы с многозадачностью

Структура создается так же как и в `предыдущей лабораторной <https://github.com/JamsAurom/kpi-embedded-course/blob/master/dk_aldokhin/lab3/README.rst>`_

Создаем две структуры: ``first_list``, ``second_list``.

**Так же нам понадобяться переменные**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* ``flags`` - массив идентификаторов работы:  flags[0]=1 работает таймер (деление на 11 не достигнуто),  flags[1]=1 работает отложенное действие (деление на 11 не достигнуто).
* ``my_work`` - объявление отложенного действия (work)
* ``my_timer`` - объявление таймера
* ``threads_crs`` - для создания потоков, типа ``struct task_struct``

**Рассмотрим функции**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Функция таймера**
"""""""""""""""""""""""""

Принимает данные типа ``struct timer_list *``.

Создание перменной типа ``long int`` и присваевается ей джифис.
Проверка деления на 11, если равно нулю, то запишем в флаг false. А если равно то создаем переменную ``temp_list`` типа ``struct struct_list *`` 
она нам понадобиться для записи листа в список. Далее выделяем память для этого листа. ``GFP_ATOMIC`` нужен для 100% уверенности выполнения
операции. так как или выделение произойдет или не произойдет вообще и выдаст ошибку, которую мы проверяем в следующем действии, если все хорошо
то мы записываем это значение в джифиса в лист, а лист добовляем в список. и ``mod_timer`` ставим джифис тот что сейчас, плюс 17. Из задания.

**Функция отложенного действия**
""""""""""""""""""""""""""""""""""""""""""""""""""

Принимает данные типа ``struct work_struct *``.

Делает все то же самое что и `Функция таймера`_ только там не таймер, а ворклет.

**Печать структуры**
"""""""""""""""""""""""""

Стандартная функция. создаем временный указатель типа нашего листа, а именно ``struct struct_list``. После чего запускаем функцию 
``list_for_each_entry`` она принимает параметры: временная переменная нашего типа, саму структуру и структуру хранящюю голову и конец списка.

**Удаление структуры**
"""""""""""""""""""""""""

Здесь нам понадобяться 3 временных переменных, две из которых типа ``struct list_head``, а другая ``struct struct_list``. 
Они нужны для передачи в функцию головы, конца списка и временной ноды.

list_for_each_safe функция помогает пройтись по всем нодам нашего списка.
Так же, внутри мы освобождаем память и очищаем все.

**Функция для первого потока**
""""""""""""""""""""""""""""""""""""""""""""""""""

Эта функция выполняется только тогда, когда флаг для нее разрешает это сделать, иначе ожидаем разрешения от таймера. 
А если все хорошо, то мы запускаем печать.

**Функция для второго потока**
""""""""""""""""""""""""""""""""""""""""""""""""""

Все то же самое только теперь для workqueue, а не для таймера

**Инициализации**
""""""""""""""""""""""""""""""""""""""""""""""""""

1. Выделяем память для двух потоков
2. Проверяем это выделение
3. Присваеваем 1 нулевому флагу
4. Инициализируем первый поток
5. Присваеваем 1 первому флагу
6. Инициализируем второй поток
7. Создаём таймер с нашей функцией таймера
8. Задаем прирывание таймеру, сейчасшний джифис + 10 секунд в джифисах
9. Создаём workqueue с его функцией
10. Задаём отложенную обработку work, сейчасшний джифис + 20 секунд в джифисах

**Выход**
"""""""""""""""""""""""""

1. Обнулить флаги и остановить потоки
2. Закрыть таймер и workqueue
3. Освобождаем память.

**Сборка и тестирование модуля**
----------------------

Тестирование проводилась на x86 и на BBB. 

Далее привожу пример распичатки BBB

.. code-block:: C

		[  835.565712] First list items (timer)		
		[  835.565725]  ---      133874				
		[  835.565730]  ---      133856				
		[  835.573674] In fanction my_work_func		
		[  835.645576] In fanction my_work_func 		
		[  835.717584] In fanction my_work_func		
		[  835.789579] In fanction my_work_func 		
		[  835.861602] In fanction my_work_func 		
		[  835.933580] In fanction my_work_func 		
		[  836.005578] In fanction my_work_func 		
		[  836.005598] Second list items (workqueue)		
		[  836.005610]  ---      133984				
		[  836.005615]  ---      133966				
		[  836.005620]  ---      133948				
		[  836.005625]  ---      133930				
		[  836.005630]  ---      133912				
		[  836.005635]  ---      133894				
		[  836.005640]  ---      133876				
		[  836.005645]  ---      133858				
		[  843.260820] Start exit					

х86:

.. code-block:: C

	[ 5623.325028] Second list items (timer)	
	[ 5623.325029]  ---     1596925				
	[ 5623.325030]  ---     1596907				
	[ 5623.325031]  ---     1596889				
	[ 5623.375061] In fanction my_timer_func 	
	[ 5623.435063] In fanction my_timer_func 	
	[ 5623.435064] First list items (workqueue)		
	[ 5623.435066]  ---     1596958				
	[ 5623.435066]  ---     1596940				
	[ 5623.435067]  ---     1596922				
	[ 5623.435067]  ---     1596904				
	[ 5623.435067]  ---     1596886				
	[ 5637.613450] Start exit					

Звідси бачимо, що х86 набагато сшидше виконує завдання, так як набагато меньша кількість прерываний.

**Вывод**
------------------

Изучили таймеры и очередь отложеных действий. Убедились что таймеры намного удобнее и лучше, так же меньше грузят ядро, так как работают по прирыванию. Протестировали код. 





