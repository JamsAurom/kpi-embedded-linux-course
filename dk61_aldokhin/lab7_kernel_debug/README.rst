=================================================
**Лабораторная работа №7 Отладка ядра**
=================================================

**Тема**: *Создание собственного драйвера и его отладка*

**Цель**: *Попробовать поработать с пециальными функциями для отладки програм*

Структура директории
-------------------------------------------
+-------------------+----------------------------------+ 
| Папка и файлы     |            Описание              |
+===================+==================================+ 
|        src        | Исходный код лабораторной работы |
+-------------------+----------------------------------+
|  src/hivemod.c    | Исходный код модуля              |
+-------------------+----------------------------------+
|  src/ioctl.h      | Библиотека для модуля и проверки |
+-------------------+----------------------------------+
|  src/Makefile     | Файл для компиляции проверки     |
+-------------------+----------------------------------+
|  src/user.c       | Исходный код функции проверки    |
+-------------------+----------------------------------+
|       Makefile    |     Файл для компиляции модуля   | 
+-------------------+----------------------------------+ 
|       README.rst  | Отчет о лабораторной работе      |
+-------------------+----------------------------------+

**Оглавление:**
----------------

      #. `Задание`_
      #. `Теория`_ 
      #. `Ход работы`_  
              #. `Настройка DebugFS`_
              #. `API отладки`_
      #. `Вывод`_


**Задание**
~~~~

Поработать с ``debugfs``, а так же попробовать запустить запустить и поработать с ``GDB`` и ``KGDB``

**Теория**
--------------

**debugfs** — это простая файловая система на основе памяти, разработанная специально для отладки кода ядра Linux, и 
ее не следует путать с утилитой файловой системы debugfs. Представленный Грегом Кроа-Хартманом в декабре 2004 года, 
debugfs помогает разработчикам ядра экспортировать большие объемы отладочных данных в пространство пользователя.

**GDB** — переносимый отладчик проекта GNU, который работает на многих UNIX-подобных системах и умеет производить 
отладку многих языков программирования, включая Си, C++, Free Pascal, FreeBASIC, Ada, Фортран и Rust. GDB — свободное 
программное обеспечение, распространяемое по лицензии GPL.

**KGDB** — является отладчиком для ядра Linux и ядер NetBSD и FreeBSD . Требуется две машины, которые подключены через 
последовательное соединение. Последовательное соединение может быть либо интерфейсом RS-232 с использованием 
нуль-модемного кабеля, либо по сетевому протоколу UDP / IP (KGDB через Ethernet, KGDBoE). Целевая машина (отлаживаемая) 
запускает исправленное ядро, а другая (хост) машина запускает gdb . Удаленный протокол GDB используется между двумя компьютерами.

**Ход работы**
-----------

**Настройка DebugFS**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Если вы используете один из последних дистрибутивов, скорее всего, Debugfs уже настроен на вашем компьютере. Если вы собираете ядро ​​с нуля, убедитесь, что вы включили debugfs в конфигурации ядра. После того, как вы перезагрузитесь в только что скомпилированное ядро, проверьте, подключен ли debugfs, с помощью следующей команды:

.. code-block:: C

  # mount | grep  debugfs
  none on /sys/kernel/debug type debugfs (rw)

Если вы видите вывод, как указано выше, у вас предварительно смонтированы debugfs. Если нет, вы можете смонтировать его (как root) с помощью команды, показанной ниже:

.. code-block:: C

  # mount -t debugfs nodev /sys/kernel/debug

Если вы хотите, чтобы он был доступен при каждой перезагрузке, добавьте /etc/fstabследующую запись :

.. code-block:: C

  debugfs /sys/kernel/debug debugfs defaults 0 0

После подключения вы можете просматривать множество файлов и каталогов /sys/kernel/debug, каждый из которых принадлежит той или иной подсистеме.

**API отладки**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Чтобы получить доступ к API, включите linux/debugfs.hв ваш исходный файл. Чтобы иметь возможность использовать debugfs, мы начинаем с создания каталога внутри /sys/kernel/debug, который является идеальным способом для начала. Остальные файлы могут быть размещены в этом каталоге.

.. code-block:: C

  struct dentry *debugfs_create_dir(const char *name, struct dentry *parent);

Здесь - имя каталога, а parent - родительский каталог (если ноль, каталог создается в /sys/kernel/debug). Если debugfs не включен в ядре, ENODEVвозвращается.

Если вам нужно создать один файл внутри debugfs, вы можете вызвать следующую функцию:

.. code-block:: C

  struct dentry *debugfs_create_file(const char *name, mode_t mode, struct dentry *parent, void *data, struct file_operations *fops);

Здесь name- имя файла, который будет создан; режим обозначает права доступа к созданному файлу; parentуказывает родительский каталог, в котором должен быть создан файл (по умолчанию - корень debugfs /sys/kernel/debug); dataэто тип inode.i_privateи fopsэто файловые операции.

Если вам нужно записывать и читать из одного значения, вы можете использовать это для создания 8-разрядного значения без знака:

.. code-block:: C

  struct dentry *debugfs_create_u8(const char *name, mode_t mode, struct dentry *parent, u8 *value);

Здесь valueуказатель на переменную, которую нужно прочитать и записать.

Несколько других вспомогательных функций для создания файлов с одиночными целыми значениями:

.. code-block:: C

  struct dentry *debugfs_create_u16
  struct dentry *debugfs_create_u32
  struct dentry *debugfs_create_u64

(Обратитесь fs/debugfs/file.cза дополнительной информацией.)

Аналогичные функции, которые выдают шестнадцатеричный вывод:

.. code-block:: C

  dentry *debugfs_create_x8(const char *name, mode_t mode, struct dentry *parent, u8 *value)
  dentry *debugfs_create_x16
  dentry *debugfs_create_x32
  ^^dentry *debugfs_create_x64

Примечание: debugfs_create_x64 это самая последняя версия API; Хуан Ин добавил в мае 2010 года, что говорит нам о том, что debugfs все еще находится в активной разработке.

В нашей программе создаем файл в инициализции модуля. 

.. code-block:: C
  
  struct dentry *junk;

  dirret = debugfs_create_dir("hive", NULL);
  if (!dirret) {
    MOD_DEBUG(KERN_ERR, "Diiret not create %d", err);
    return -ENOMEM;
  }

  junk = debugfs_create_file("debug", 0222, dirret, NULL, &fops_debug);     
  if (!junk) {
    MOD_DEBUG(KERN_ERR, "File not create %d", err);
    return -ENOMEM;
  }

  junk = debugfs_create_blob("test", 0777, dirret, blob_d);
  if (!junk) {
    MOD_DEBUG(KERN_ERR, "BLOB not create %d", err);
    return -ENOMEM;
  }
     
  blob_d = kmalloc(sizeof(struct debugfs_blob_wrapper), GFP_KERNEL);

  if (!blob_d) {
    MOD_DEBUG(KERN_ERR, "BLOB not mem %d", err);
    return -ENOMEM;
  }

  blob_d->data = (void *)magic_phrase;
  blob_d->size = buffsize / 2;
     
  junk = debugfs_create_u64("sum_test", 0777, dirret, &sum);
  if (!junk) {
    MOD_DEBUG(KERN_ERR, "sum not create %d", err);
    return -ENOMEM;
  }

Можно замеить что первая часть - создание дерриктории.

Вторая часть - создание файла.

Далее пишем данные в файл.

Файл можно найти по адресу: ``admin:///sys/kernel/debug/hive``

**Вывод**
------------------

Для тестирования лучше всего использовать ``printk``, так как этот метод самый стабильный и показательный, так же можно использовать 
``debugfs`` это достаточно показательный метод.





