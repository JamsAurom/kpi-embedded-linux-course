=================================================
**Лабораторная работа №3 Связный список и потоки ядра**
=================================================

**Тема**: *Принципы работы со списками в ядре, потоки и механизмы синхронизации*

**Цель**: *Научиться синхронизировать потоки в Linux*

Структура директории
-------------------------------------------
+-------------------+----------------------------------+ 
| Папка и файлы     |            Описание              |
+===================+==================================+ 
|        src        | Исходный код лабораторной работы |
+-------------------+----------------------------------+ 
|        img        | Исходный изображения к отчету    |
+-------------------+----------------------------------+
|       Makefile    |     Файл для компиляции проекта  | 
+-------------------+----------------------------------+ 
|       README.rst  | Отчет о лабораторной работе      |
+-------------------+----------------------------------+

**Оглавление:**
----------------

      #. `Задание`_
      #. `Ход работы`_  
              #. `В проекте используються библиотеки`_
              #. `Разберем код объявления переменных`_
                        #. `Переменные`_
                        #. `Объявление структуры`_
                        #. `Далее описываем создание глобальных списков`_
                        #. `Объявляем переменные`_
              #. `Далее расмотрим функции`_
                        #. `Функция закрытия (``lock``)потока`_
                        #. `Функция открытия (``unlock``)потока`_
                        #. `Основная функция потока`_
                        #. `Функция инициализации`_
                        #. `Функция выхода`_
              #. `Три варианта записи прав пользователя`_
      #. `Сборка и тестирование модуля`_
      #. `Вывод`_


**Задание**
~~~~
* содержит переменную
* запускает M потоков на одновременное выполнение
* каждый поток инкрементирует переменную N раз, кладет значение переменной в список и завершается
* при выгрузке модуль выводит значение переменной и содержимое списка
* использовать параметры модуля для задания инкремента N и количества потоков M (в коде параметры должны называться осмысленно)
* для переменной, списка, потоков использовать динамическую аллокацию. Переменную передавать в поток по ссылке аргументом

**Ход работы**
-----------

В проекте используються библиотеки
~~~~
* ``<linux/module.h>`` требуется для всех модулей
* ``<linux/kernel.h>`` требуется для системной информации
* ``<linux/init.h>`` используется для инициализации и закрытия модуля
* ``<linux/list.h>`` для создания списков
* ``<linux/interrupt.h>`` используется для задач
* ``<linux/slab.h>`` для более эффективного управления памятью
* ``<linux/kthread.h>`` для взаимодействия с потоками данных
* ``<asm/atomic.h>`` для атомарных операций (операция, которая либо выполняется целиком, либо не выполняется вовсе; операция, которая не может быть частично выполнена и частично не выполнена.)

В модуле должны быть основные разделы, такие как:

* инициализация
* выход

В нашем случае все основные операции будут проходить в инициализации. Объявление перемнных, объявление N потоков. Запуск этих же потоков. 
В функции выхода будет вывод данных (списка) в терминал и освобождение памяти.
Функция потока, будет только итерировать данные переменную и все.
Так же понадобяться функции блокирования потока ``static void lock(atomic_t *arg)`` и его разблокирование 
``static void unlock(atomic_t *arg)`` это достаточно простые функции, расмотрим их далее. 

**Разберем код объявления переменных**
~~~~~~~~~~~~~~~~~~

**Переменные**
""""""""""""""""""""""""""""""""""""
* ``iterator`` входной параметр, который определяет на сколько итерировать значение.
* ``kernel_quantity`` количество потоков которое надо будет создать для выполнения итерирования.

К переменным вернемся далее, а пока **ввод параметров**

.. code-block:: C

   module_param(iterator, int, 0);
   MODULE_PARM_DESC(iterator, "How much to iterate the variable?");

В ``module_param`` мы должны передать переменную, тип данных и права доступа(таблица будет приведена ниже `Три варианта записи прав пользователя`_)

``MODULE_PARM_DESC`` испльзуется при вызове ``modinfo`` для вывода более подробной информации о модуле.

**Объявление структуры**
""""""""""""""""""""""""""""""""""""

Структура ``list_rez`` нужна для вывода данных. В ней воспользуемся библиотекой ``<linux/list.h>`` из нее берем ``struct list_head`` эта структура
поможет объявить голову и конец списка, так же будет хронить ссылку на предыдущий и следующий эллемент.

.. code-block:: C

    struct list_rez {
      int rez;
      struct list_head m_list;
    };
    
**Далее описываем создание глобальных списков**
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Нам в этом поможет рисунок

.. image:: img/ldd_list_head_data_structure.png

На нем слева видем:


* ``struct list_head`` именно это нам помагает объявить ``<linux/list.h>`` в `Объявление структуры`_ 
* Ниже именно то наша структура

``LIST_HEAD(out_list);`` помогает проинициализировать список.
``struct list_rez *out_list_acc;`` создает список ``out_list_acc``.
 
**Объявляем переменные**
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

``atomic_t *kernel_s = NULL;`` создаем атомарную переменную и объявляем ее равной ``NULL``, нужна для блокировки потоков.

``int *iter = NULL;`` создаем переменную глобальную которую будем итерировать.

**Далее расмотрим функции**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Функция закрытия (``lock``) потока**
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

.. code-block:: C

            static void lock(atomic_t *arg)
            {
                  while (atomic_cmpxchg(arg, 0, 1));
            } 

Ждет пока поток освободиться, выяснить это можно по флажку ``arg``. Функция ``atomic_cmpxchg`` принимает три параметра:

* указатель на атомарную переменную, которую проверяем
* с чем сравниваем
* новое значение которому присваеваем

**Функция открытия (``unlock``) потока**
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Работает аналогично `Функция закрытия (``lock``)потока`_ только уже нет ожидания, так как и так поток уже занят именно этим залоченым процессом.

``atomic_set`` принимает два параметра:

* атомарный флажек, кого изменить.
* и какое значение принять, в нашем случае это 0.

**Основная функция потока**
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Она называется ``thread_f`` принимает аргумент типа ``void *`` так можно передавать указатель на список или массив, передавая более одной переменной в функцию, возвращает тип ``int`` с кодом ошибки.

В функции все просто, пройдемся только по основным пунктам:

1. залочить поток, что бы другой не мог менять значения итерируемой переменной
2. итерирование переменной столько раз, сколько было передано в модуль через параметр
      2.1. стоит обратить внимание на функцию ``schedule();`` она сообщает планировщику выполнять следующую операцию, так уменьшается вероятность ошибок
3. выделение памяти под новый элемент структуры. ``GFP_KERNEL`` - нужен что бы операция не засыпала, обязательно для всех модулей ядра
4. проверка на выделение памяти, если нет, то все пропало, выдаем ошибки и сворачиваемся подчищая за собой память
5. если все норм идем дальше. Присваиваем проитерирывающийся эллемент списку
6. добавляем наш элемент списка в начало основного списка с помощтю функции ``list_add``. Два параметра: кого добавить, куда добавить
7. Разлочить поток и закрыться

**Функция инициализации**
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

С этой функции стартует все выполнения модуля, здесь будем действовать так же как и в прошлой функции, пройдемся в кратце, так как просто алгоритм действий важен:

1. выделение памяти для атомарной переменной - флажка, которая лочит потоки
2. проверка ее выделения
3. присвоение ей значения 0
4. выделение памяти для переменной которую итерируем
5. проверка ее выделения
6. создание переменной типа: ``struct task_struct`` нужна для создания массива потоков
7. обнуления ее же
8. выделения памяти кратной количеству потоков, введеный в параметре
9. проверка ее выделения
10. обнуления итератора
11. основной цикл создания потоков и вызова функции потока, делается это спомощью функции ``kthread_run``, принимает переменные: какую функцию запустить, что в нее передать, название потока.
12. окончание функции

**Функция выхода**
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

Освобождаем всю память и выводим список последовательно.

Основной итерес к функции - циклу ``list_for_each_safe`` она выводит и освобождает память от списка. 3 параметра принимает: голова списка, конец списка и сам список. 

.. code-block:: C

      list_for_each_safe(pos, q, &out_list) {
            out_list_acc = list_entry(pos, struct list_rez, m_list);
            printk(KERN_NOTICE "--%d\n", out_list_acc->rez);
            list_del(pos);
            kfree(out_list_acc);
      }


**Три варианта записи прав пользователя**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+------------------------+--------------------------+------------------------+--------------------------+----------------------------+
| двоичная               | восьмеричная             | символьная             | права на файл            | права на каталог           |
+------------------------+--------------------------+------------------------+--------------------------+----------------------------+
| 000                    | 0                        | ---                    | нет                      | нет                        |
+------------------------+--------------------------+------------------------+--------------------------+----------------------------+
| 001                    | 1                        | --x                    | выполнение               | чтение файлов и их свойств |
+------------------------+--------------------------+------------------------+--------------------------+----------------------------+
| 010                    | 2                        | -w-                    | запись                   | нет                        |
+------------------------+--------------------------+------------------------+--------------------------+----------------------------+
| 011                    | 3                        | -wx                    | запись и выполнение      | всё, 001                   |
+------------------------+--------------------------+------------------------+--------------------------+----------------------------+
| 100                    | 4                        | r--                    | чтение                   | чтение имён файлов         |
+------------------------+--------------------------+------------------------+--------------------------+----------------------------+
| 101                    | 5                        | r-x                    | чтение и выполнение      | доступ на чтение           |
+------------------------+--------------------------+------------------------+--------------------------+----------------------------+
| 110                    | 6                        | rw-                    | чтение и запись          | чтение имён файлов         |
+------------------------+--------------------------+------------------------+--------------------------+----------------------------+
| 111                    | 7                        | rwx                    | все права                | все права                  |
+------------------------+--------------------------+------------------------+--------------------------+----------------------------+

Так же надо напомнить про макросы для вывода информации в командную строку
``printk`` используется для вывода информации в консоль, имеет макросы:
~~~~
* ``KERN_EMERG`` - Система не используется
* ``KERN_ALERT`` - Действие должно быть принято немедленно
* ``KERN_CRIT`` - Критические условия
* ``KERN_ERR`` - Условия ошибки
* ``KERN_WARNING`` - Условия предупреждения
* ``KERN_NOTICE`` - Нормальное, но значимое состояние
* ``KERN_INFO`` - информационный
* ``KERN_DEBUG`` - Сообщения уровня отладки

Сборка и тестирование модуля 
---------------------------

После запуска и тестирования модулей ядра на 1000 эллементов и итерацией до 666 имеем такое время:

* BBB - 2мин 18сек
* х86 - 0мин 3сек

Сразу понятно на сколько более производительный x86 двухядерный с 4 потоками)). Так что BBB надо набирать больше мускулов что бы отвечать требованиям.

Список вывелся при закрытие модуля, не думаю что это стоит приводить в отчете, так как ошибок выявлено не было.

Вывод
----

Был собран и проверен модуль ядра. Убедились в его выполнении. Был престирован до 100000 потоков, выполнялся правильно, хоть и долго. проанализирован вывод данных, все совпадало. Ошибок выявлено не было.




