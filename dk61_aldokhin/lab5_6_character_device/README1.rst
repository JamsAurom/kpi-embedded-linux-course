=================================================
**Лабораторная работа №5,6 Символьное устройство**
=================================================

**Тема**: *Создание собственного драйвера*

**Цель**: *Научиться работать с драйверами(функции ввода, вывода, чтение файла) в Linux*

Структура директории
-------------------------------------------
+-------------------+----------------------------------+ 
| Папка и файлы     |            Описание              |
+===================+==================================+ 
|        src        | Исходный код лабораторной работы |
+-------------------+----------------------------------+
|  src/hivemod.c    | Исходный код модуля              |
+-------------------+----------------------------------+
|  src/ioctl.h      | Библиотека для модуля и проверки |
+-------------------+----------------------------------+
|  src/Makefile     | Файл для компиляции проверки     |
+-------------------+----------------------------------+
|  src/user.c       | Исходный код функции проверки    |
+-------------------+----------------------------------+
|       Makefile    |     Файл для компиляции модуля   | 
+-------------------+----------------------------------+ 
|       README.rst  | Отчет о лабораторной работе      |
+-------------------+----------------------------------+

**Оглавление:**
----------------

      #. `Задание`_
      #. `Теория`_ 
      #. `Ход работы`_  
              #. `Модуль ядра`_
                        #. `В проекте используються библиотеки`_
                        #. `Рассмотрим структуры`_
                        #. `Рассмотрим переменные глобальные`_
                        #. `Рассмотрим функции`_
                              #. `Функция создания эллемента списка с буфером`_
                              #. `Функция удаления эллемента списка с буфером`_
                              #. `Функция поиска в списке`_
                              #. `Операция открытия`_
                              #. `Операция закрития`_
                              #. `Операция чтения`_
                              #. `Операция записи`_
                              #. `Операция двусторонняя функция ioctl`_
                              #. `Очень важная штука`_
                              #. `Операция очистки модуля`_
                              #. `Операция инициализации`_
              #. `Пользовательская функция`_
                        #. `В проекте используються библиотеки пользователя`_
                        #. `Рассмотрим переменные глобальные пользователя`_
                        #. `Рассмотрим функции пользователя`_
                              #. `Функция подготовки`_
                              #. `Функция тестирования`_
                              #. `Основная функция`_
      #. `Сборка и тестирование модуля`_
            #. `х86`_
            #. `ВВВ`_
      #. `Вывод`_


**Задание**
--------------

Препадователем был выдан модуль, в котором надо было внести определенные фиксы в код, так же дописать некоторые функции и оптимизировать код. Функции, такие как: ``ioctl``. 

**Теория**
--------------

При проектировании нового драйвера предстоит ответить для себя на три группы вопросов (по каждому из них возможны альтернативные ответы):
1.	Каким способом драйвер будет регистрироваться в системе (под парой номеров major и minor), как станет известно системе, что у неё появился в распоряжении новый драйвер и новое устройство?
2.	Каким образом драйвер создаёт (или использует созданное внешними средствами) имя соответствующего ему устройства в каталоге /dev, и как он (драйвер) связывает это имя с  major и minor номерами этого устройства?
3.	После того, как драйвер увязан с устройством, какие будут использованы особенности в реализации основных операций обслуживания устройства (open(), read(), ...)?

**Регистрация драйверов в системе** происходит с помощью пары номеров: major, minor. Но так же надо связать номер устройства с его имеем, по сути это сказать модулю: если что то обращается по этому имени, то это твоя работа, делай ее.

**file_operations** - содержит указатели на функции драйвера, которые отвечают за выполнение различных операцийс утройством. (по сути вся работа с ``/dev`` реализована через эту структуру)

**Ход работы**
-----------

**Модуль ядра**
""""""""""""""""

**В проекте используються библиотеки**
~~~~~~~~~~~~~~~~~~

* ``<linux/module.h>`` требуется для всех модулей
* ``<linux/kernel.h>`` требуется для системной информации
* ``<linux/init.h>`` используется для инициализации и закрытия модуля
* ``<linux/list.h>`` для создания списков
* ``<linux/jiffies.h>`` количество импульсов системного таймера
* ``<linux/fs.h>`` содержит структуру file_operations подробнее в теории
* ``<linux/errno.h>`` коды ошибок
* ``<linux/slab.h>``
* ``<linux/cdev.h>`` автоматически выделяет старший номер и связывает с младшим
* ``<linux/uaccess.h>`` API помогает обмениваться данными
* ``<linux/miscdevice.h>`` помогает выбрать номер и зарегестрировать устройство

**Рассмотрим структуры**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``alloc_status`` - битовое поле, хранит флаги создания драйвера

Рассмотрим данные которые хранит структура

* ``dev_created`` - зарегистрировано в системе
* ``cdev_added`` - установка связи в системе

``hive_file_item`` - хранит данные для каждого дескриптора

Рассмотрим данные которые хранит структура

* ``buffer`` память, которую мы выделяем для каждого файла
* ``length`` размер буфера
* ``rdoffset`` смещение чтения
* ``wroffset`` смещение записи

``hive_flist_item`` - учет открытых дескрипторов

Рассмотрим данные которые хранит структура

* ``list`` поля для связывания списка
* ``file`` создается в ``open()``, удаляется при изменениях ``close()``

**Рассмотрим переменные глобальные**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``hive_flist`` - список 

**Рассмотрим функции**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Функция создания эллемента списка с буфером**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Имя функции ``hive_flist_new`` она inline.

Принимает значения типа: ``unsigned long buffer_size``

Возвращает данные типа: ``struct hive_flist_item *``

По сути функция просто выделяет память типа ``struct hive_flist_item *`` эллементу и возвращает его.
Так же есть проверка на корректность выделения памяти.

**Функция удаления эллемента списка с буфером**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Имя функции ``hive_flist_rm`` она inline.

Принимает значения типа: ``struct hive_flist_item``

Возвращает данные типа: ``void``

Функция проверяет, если такой эллемент существует, то удаляем его из списка и чистим память, если нет, то выходим из функции.

**Функция поиска в списке**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Имя функции ``hive_flist_get``

Принимает значения типа: ``struct file``

Возвращает данные типа: ``int``

Функция линейно по списку ищет нужное значение (входное), если находит то возвращает номер єтого єллемента, а если нет то ``NULL``. Поиск реализован линейно.

**Операция открытия**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Имя функции ``cdev_open``

Принимает значения типа: ``struct inode *``, ``struct file *``

Возвращает данные типа: ``int``

Создаем два эллемета, двух разных структур: ``hive_file_item *``, ``hive_flist_item *``. Это нужна для определения девайса, создание буфера, чтения и записи. Нужна для работы с девайсом, что бы его инициализировать.

**Операция закрития**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Имя функции ``cdev_release``

Принимает значения типа: ``struct inode *``, ``struct file *``

Возвращает данные типа: ``int``

Операция нужна для закрытия устройства. Удаляем и освобождаем эллемент типа ``hive_file_item *`` то же самое делаем с ``hive_flist_item *``.

**Операция чтения**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Имя функции ``cdev_read``

Принимает значения типа: ``struct file *``, ``char __user *``, ``size_t``, ``loff_t *``

Возвращает данные типа: ``ssize_t``

Функция чтения файла, именно его и размер буфера принимает функция так же еще запрос для чтения в буфер и позицию начала чтения. 

**Операция записи**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Имя функции ``cdev_write``

Принимает значения типа: ``struct file *``, ``char __user *``, ``size_t``, ``loff_t *``

Возвращает данные типа: ``ssize_t``

Функция записи файла, пишет данные определенного размера в файл. Так же надо не забыть добавить ``\0`` для конца файла.

**Операция двусторонняя функция ioctl**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Имя функции ``cdev_ioctl``

Принимает значения типа: ``struct file *``, ``unsigned int``, ``unsigned long``

Возвращает данные типа: ``long``

Принимает данные: файл, команда и параметр.

**Очень важная штука**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      .. code-block:: C
      
      static struct file_operations hive_fops = {
      	.open =           &cdev_open,
      	.release =        &cdev_release,
      	.read =           &cdev_read,
      	.write =          &cdev_write,
      	.unlocked_ioctl = &cdev_ioctl,
      	// required to prevent module unloading while fops are in use
      	.owner =          THIS_MODULE,
      };

Тут мы говорим какая функция, которую вызывает пользователь, выполняется в модуле. По сути это инерпритатор имен, скажем так.

**Операция очистки модуля**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Имя функции ``module_cleanup``

Принимает значения типа: ``void``

Возвращает данные типа: ``void``

Память освобождаем в обратном порядке, все как всегда. Это освобождение при выгрузке модуля ядра.

Дальше идут функции инициализации и закрытия.

**Операция инициализации**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Имя функции ``cdevmod_init``

Принимает значения типа: ``void``

Возвращает данные типа: ``int``

В начале надо проверить, ввели мы параметр или нет, если нет, то создаем с тем номером, что выбрали. Дальше идут проверки, 

**Пользовательская функция**
""""""""""""""""""""""""""""""""

**В проекте используються библиотеки пользователя**
~~~~~~~~~~~~~~~~~~

* ``<fcntl.h>`` параметры управления файлами
* ``<stdio.h>`` Полезные функции, по типу printf(), scanf()
* ``<stdlib.h>`` функции выделения памяти и все в этом духе, стандартная либа
* ``<string.h>`` стандартная библиотека, текстового типа
* ``<sys/ioctl.h>`` для взаимодействия с пользователем, внешними входами и выходами

Так же понадобиться собственная библиотека ``"ioctl.h"`` для буфера.

**Рассмотрим переменные глобальные пользователя**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``dev`` - имя для адресации к модулю 

**Рассмотрим функции пользователя**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Функция подготовки**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Имя функции ``prepare``

Принимает значения типа: ``char *``

Возвращает данные типа: ``int``

Функция должна обратиться к модулю, что бы индефицироать устройсво. Далее запишим данные, те которые мы ввели в модуле.

**Функция тестирования**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Имя функции ``test``

Принимает значения типа: ``int``

Возвращает данные типа: ``void``

Эта функция тестирует наши наработки. Далее создаем переменную длиной нашего буфера (она объявлена дефайном в шопке). После чего мы считываем данные. 

**Основная функция**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Имя функции ``main``

Принимает значения типа: ``int``, ``char *``

Возвращает данные типа: ``int``

Открывает два устройства, а потом тестирует каждое из них, после чего мы так же мы считываем фразу из модуля, которая там была объявлена и все закрываем.

**Сборка и тестирование модуля**
----------------------

При тестировании была обноружена проблема, что автоматически не выдает имя модулю. По этому была использованы команды:

::

     sudo dmesg | tail -n2
     ls -l /dev/test23 | grep 240

``test23`` - это просто название, а 240, это наш мажер, его мы смотрим преыдущей командой, нам выдадет мажер и минор та команда. А перед этим надо запустить модуль: ``sudo insmod ./.build/hivemod.ko``

``sudo mknod /dev/ c 240 0`` - а так можно проверить нормально ли присвоились названия

После чего надо собрать и запустить программу пользователя (запускаем от имини администратора). 

Теперь продемонстрируем результат работы 

**х86**
""""""""""""""""

::

      prepared 7 bytes: 1111111
      prepared 5 bytes: 22222
      ------------------------------------
      read 17 bytes: 1111111
      read end of stream
      ------------------------------------
      ------------------------------------
      read 17 bytes: 22222
      read end of stream
      ------------------------------------
      Wow, we made these bees TWERK !
      
      real  0m0,024s
      user  0m0,016s
      sys  0m0,006s

**ВВВ**
""""""""""""""""

::

      prepared 7 bytes: 1111111
      prepared 5 bytes: 22222
      ------------------------------------
      read 9 bytes: 1111111
      read end of stream
      ------------------------------------
      ------------------------------------
      read 9 bytes: 22222
      read end of stream
      ------------------------------------
      Wow, we made these bees TWERK !
      
      real  0m0.083s
      user  0m0.022s
      sys  0m0.037s

Отсюда видем, впрочем как и всегда, что ВВВ медленнее почти в 3 раза. Так же видем что оба девайса заработали, и вывелась корректно коронная фраза. Которая была в задании. Так что модуль коректен.

После чего выгружаем модуль: ``sudo rmmod .build/hivemod.ko``

**Вывод**
------------------

Была проведена большая работа по разработке модуля. Так же была протестировн модуль и функция. 




