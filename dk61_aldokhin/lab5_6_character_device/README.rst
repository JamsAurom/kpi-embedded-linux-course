=================================================
**Лабораторная работа №4 Символьное устройство**
=================================================

**Тема**: *Создание собственного драйвера*

**Цель**: *Научиться работать с драйверами(функции ввода, вывода, чтение файла) в Linux*

Структура директории
-------------------------------------------
+-------------------+----------------------------------+ 
| Папка и файлы     |            Описание              |
+===================+==================================+ 
|        src        | Исходный код лабораторной работы |
+-------------------+----------------------------------+
|  src/hivemod.c    | Исходный код модуля              |
+-------------------+----------------------------------+
|  src/ioctl.h      | Библиотека для модуля и проверки |
+-------------------+----------------------------------+
|  src/Makefile     | Файл для компиляции проверки     |
+-------------------+----------------------------------+
|  src/user.c       | Исходный код функции проверки    |
+-------------------+----------------------------------+
|       Makefile    |     Файл для компиляции модуля   | 
+-------------------+----------------------------------+ 
|       README.rst  | Отчет о лабораторной работе      |
+-------------------+----------------------------------+

**Оглавление:**
----------------

      #. `Задание`_
      #. `Теория`_ 
      #. `Ход работы`_  
              #. `В проекте используються библиотеки`_
              #. `Так же нам понадобяться переменные`_
              #. `Рассмотрим функции`_ 
                        #. `Функция таймера`_
                        #. `Функция отложенного действия`_
                        #. `Печать структуры`_
                        #. `Удаление структуры`_
                        #. `Функция для первого потока`_
                        #. `Функция для второго потока`_
                        #. `Инициализации`_
                        #. `Выход`_
      #. `Сборка и тестирование модуля`_
      #. `Вывод`_


**Задание**
~~~~

Препадователем был выдан модуль, в котором надо было внести определенные фиксы в код, так же дописать некоторые функции и оптимизировать код. Функции, такие как: ``ioctl``. 

**Теория**
--------------

**Регистрация** драйверов в системе происходит спомощью пары номеров: ``major``, ``minor``. Но так же надо связать номер устройства с его имеем, по сути это сказать модулю: если что то обращается по этому имени, то это твоя работа, делай ее. Сейчас имена номера выделяються динамически, ранее было не так. С ядра 2.4, за один ``major`` отвечал один модуль. Потом, с ядра 2.6 у каждого ``major`` могло быть 2 модуля (делилось попалам 1 - [0-63], 2 - [64-127]) А сейчас динамическое выделение.

**file_operations** - содержит указатели на функции драйвера, которые отвечают за выполнение различных операцийс утройством. (по сути вся работа с ``/dev`` реализована через эту структуру)

**Ход работы**
-----------

### **Модуль ядра**

#### **В проекте используються библиотеки**

* ``<linux/module.h>`` требуется для всех модулей
* ``<linux/kernel.h>`` требуется для системной информации
* ``<linux/init.h>`` используется для инициализации и закрытия модуля
* ``<linux/list.h>`` для создания списков
* ``<linux/jiffies.h>`` количество импульсов системного таймера
* ``<linux/fs.h>`` содержит структуру file_operations подробнее в теории
* ``<linux/errno.h>`` коды ошибок
* ``<linux/slab.h>``
* ``<linux/cdev.h>`` автоматически выделяет старший номер и связывает с младшим
* ``<linux/uaccess.h>`` API помогает обмениваться данными
* ``<linux/miscdevice.h>`` помогает выбрать номер и зарегестрировать устройство

#### **Рассмотрим структуры**

``alloc_status`` - битовое поле, хранит флаги выделения ресурсов

Рассмотрим данные которые хранит структура

* ``dev_created`` - устройство пользователя было успешно создано
* ``cdev_added`` - адрес устройства

``hive_file_item`` - stores data for each descriptor

Рассмотрим данные которые хранит структура

* ``buffer`` память, которую мы выделяем для каждого файла
* ``length`` размер буфера
* ``rdoffset`` смещение чтения
* ``wroffset`` смещение записи

``hive_flist_item`` - учет открытых дескрипторов

Рассмотрим данные которые хранит структура

* ``list`` поля для связывания списка
* ``file`` создается в ``open()``, удаляется при изменениях ``close()`` во время файловых операций, но ptr остается прежним

#### **Рассмотрим переменные глобальные**

``hive_flist`` - список 

#### **Рассмотрим функции**

##### **Функция создания эллемента списка с буфером**

Имя функции ``hive_flist_new`` она inline.

Принимает значения типа: ``unsigned long buffer_size``

Возвращает данные типа: ``struct hive_flist_item *``

По сути функция просто выделяет память типа ``struct hive_flist_item *`` эллементу и возвращает его.
Так же есть проверка на корректность выделения памяти.

##### **Функция удаления эллемента списка с буфером**

Имя функции ``hive_flist_rm`` она inline.

Принимает значения типа: ``struct hive_flist_item``

Возвращает данные типа: ``void``

Функция проверяет, если такой эллемент существует, то удаляем его из списка и чистим память, если нет, то выходим из функции.

##### **Функция поиска в списке**

Имя функции ``hive_flist_get``

Принимает значения типа: ``struct file``

Возвращает данные типа: ``int``

Функция принимает с

**Удаление структуры**

Здесь нам понадобяться 3 временных переменных, две из которых типа ``struct list_head``, а другая ``struct struct_list``. 
Они нужны для передачи в функцию головы, конца списка и временной ноды.

list_for_each_safe функция помогает пройтись по всем нодам нашего списка.
Так же, внутри мы освобождаем память и очищаем все.

**Функция для первого потока**
""""""""""""""""""""""""""""""""""""""""""""""""""

Эта функция выполняется только тогда, когда флаг для нее разрешает это сделать, иначе ожидаем разрешения от таймера. 
А если все хорошо, то мы запускаем печать.

**Функция для второго потока**
""""""""""""""""""""""""""""""""""""""""""""""""""

Все то же самое только теперь для workqueue, а не для таймера

**Инициализации**
""""""""""""""""""""""""""""""""""""""""""""""""""

1. Выделяем память для двух потоков
2. Проверяем это выделение
3. Присваеваем 1 нулевому флагу
4. Инициализируем первый поток
5. Присваеваем 1 первому флагу
6. Инициализируем второй поток
7. Создаём таймер с нашей функцией таймера
8. Задаем прирывание таймеру, сейчасшний джифис + 10 секунд в джифисах
9. Создаём workqueue с его функцией
10. Задаём отложенную обработку work, сейчасшний джифис + 20 секунд в джифисах

**Выход**
"""""""""""""""""""""""""

1. Обнулить флаги и остановить потоки
2. Закрыть таймер и workqueue
3. Освобождаем память.

**Сборка и тестирование модуля**
----------------------

Тестирование проводилась на x86 и на BBB. 

Далее привожу пример распичатки BBB

.. code-block:: C

		[  835.565712] First list items (timer)		
		[  835.565725]  ---      133874				
		[  835.565730]  ---      133856				
		[  835.573674] In fanction my_work_func		
		[  835.645576] In fanction my_work_func 		
		[  835.717584] In fanction my_work_func		
		[  835.789579] In fanction my_work_func 		
		[  835.861602] In fanction my_work_func 		
		[  835.933580] In fanction my_work_func 		
		[  836.005578] In fanction my_work_func 		
		[  836.005598] Second list items (workqueue)		
		[  836.005610]  ---      133984				
		[  836.005615]  ---      133966				
		[  836.005620]  ---      133948				
		[  836.005625]  ---      133930				
		[  836.005630]  ---      133912				
		[  836.005635]  ---      133894				
		[  836.005640]  ---      133876				
		[  836.005645]  ---      133858				
		[  843.260820] Start exit					

х86:

.. code-block:: C

	[ 5623.325028] Second list items (timer)	
	[ 5623.325029]  ---     1596925				
	[ 5623.325030]  ---     1596907				
	[ 5623.325031]  ---     1596889				
	[ 5623.375061] In fanction my_timer_func 	
	[ 5623.435063] In fanction my_timer_func 	
	[ 5623.435064] First list items (workqueue)		
	[ 5623.435066]  ---     1596958				
	[ 5623.435066]  ---     1596940				
	[ 5623.435067]  ---     1596922				
	[ 5623.435067]  ---     1596904				
	[ 5623.435067]  ---     1596886				
	[ 5637.613450] Start exit					

Звідси бачимо, що х86 набагато сшидше виконує завдання, так як набагато меньша кількість прерываний.

**Вывод**
------------------

Изучили таймеры и очередь отложеных действий. Убедились что таймеры намного удобнее и лучше, так же меньше грузят ядро, так как работают по прирыванию. Протестировали код. 






